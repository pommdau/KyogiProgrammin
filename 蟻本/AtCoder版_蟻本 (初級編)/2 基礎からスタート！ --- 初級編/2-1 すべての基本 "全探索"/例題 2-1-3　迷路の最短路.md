## 例題 2-1-3　迷路の最短路
### 本書
TODO:

### [ABC 007 C 幅優先探索　(まんまです)](https://atcoder.jp/contests/abc007/tasks/abc007_3)
- 今回に限っては周りが`#`で囲まれているので、indexのOutOfRangeの確認が不必要となる
- [Pythonのdequeでキュー、スタック、デック（両端キュー）を扱う](https://note.nkmk.me/python-collections-deque/)

``` Python
from collections import deque


# 幅優先探索
def bfs(maze, maze_info, starting_y, starting_x, goal_y, goal_x):
    # スタート地点の設定
    queue = deque([[starting_y, starting_x]])
    maze_info[starting_y][starting_x] = 0

    while queue:
        y, x = queue.popleft()  # キューでは左側のオブジェクトのが古い（indexが0が最古）
        if [y, x] == [goal_y, goal_x]:  # ゴールの場合
            return maze_info[y][x]
        for dy, dx in ([1, 0], [-1, 0], [0, 1], [0, -1]):  # 順に上・下・右・左
            new_y, new_x = y + dy, x + dx
            if maze[new_y][new_x] == "." and \
                    maze_info[new_y][new_x] == -1:  # 通行可能かつ未到達の場合
                maze_info[new_y][new_x] = maze_info[y][x] + 1
                queue.append([new_y, new_x])  # 探索のキューに追加する


def solve():
    number_of_rows, number_of_columns = list(map(int, input().split()))  # Row, Column数
    starting_y, starting_x = list(map(int, input().split()))  # Start Point
    goal_y, goal_x = list(map(int, input().split()))  # Goal Point
    # 与えられた座標を、プログラム側の実装に合わせる
    starting_y -= 1
    starting_x -= 1
    goal_y -= 1
    goal_x -= 1

    maze = [input() for _ in range(number_of_rows)]  # maze:迷路
    maze_info = [[-1] * number_of_columns for _ in range(number_of_rows)]  # スタート地点からそのマスにいくまでの最短距離

        print(bfs(maze, maze_info, starting_y, starting_x, goal_y, goal_x))
```

### [ABC 088 D Grid Repainting　(予め盤面をいじるタイプの問題は今後よく出て来ます、頭を柔軟にして解いてみましょう)](https://atcoder.jp/contests/abc088/tasks/abc088_d)
- BFSでほぼ完成ですね。

``` Python
from _collections import deque


def bfs(field, field_info, starting_y, starting_x, goal_y, goal_x):
    queue = deque([[starting_y, starting_x]])
    field_info[starting_y][starting_x] = 1

    while queue:
        y, x = queue.popleft()
        for dy, dx in ([1, 0], [-1, 0], [0, 1], [0, -1]):
            new_y, new_x = y + dy, x + dx
            if 0 <= new_y <= goal_y and 0 <= new_x <= goal_x and field[new_y][new_x] == "." and field_info[new_y][new_x] == -1:
                field_info[new_y][new_x] = field_info[y][x] + 1
                queue.append([new_y, new_x])


def solve():
    number_of_rows, number_of_columns = list(map(int, input().split()))  # Row, Column数
    field = [input() for _ in range(number_of_rows)]
    field_info = [[-1] * number_of_columns for _ in range(number_of_rows)]
    starting_y, starting_x = 0, 0
    goal_y, goal_x = number_of_rows - 1, number_of_columns - 1
    bfs(field, field_info, starting_y, starting_x, goal_y, goal_x)

    # # BFSの結果をチェック
    # for field_info_line in field_info:
    #     print(field_info_line)

    if field_info[goal_y][goal_x] == -1:
        print(-1)
        return
    else:   # 到達できる場合
        number_of_black_cell = 0
        for row_i in range(number_of_rows):
            for column_i in range(number_of_columns):
                if field[row_i][column_i] == "#":
                    number_of_black_cell += 1
        point = number_of_columns * number_of_rows - field_info[goal_y][goal_x] - number_of_black_cell
        print(point)
```

### [AGC 033 A \- Darker and Darker　\(多点スタートな問題です\)](https://atcoder.jp/contests/agc033/tasks/agc033_a)

#### [回答例：AtCoder AGC 033 A \- Darker and Darker \(300 点\) \- けんちょんの競プロ精進記録](http://drken1215.hatenablog.com/entry/2019/05/05/223200)
- 白マス基準でいくと良い。


#### 自分の回答（TLE）

- 残念ながらTLE…
- 流れ：
    - 各`#`マス（黒マス）を始点としてBFSを行う
    - 各BFSの結果を比較して、それぞれのマスの最小値を算出する
    - その結果の全マスの中での最大値が、今回求める試行回数である

``` Python
from collections import deque
from copy import deepcopy


# 幅優先探索
def bfs(field, field_info, number_of_rows, number_of_columns, starting_y, starting_x):
    queue = deque([[starting_y, starting_x]])
    field_info[starting_y][starting_x] = 0

    max_distance = 0
    while queue:
        y, x = queue.popleft()
        for dy, dx in ([1, 0], [-1, 0], [0, 1], [0, -1]):
            new_y, new_x = y + dy, x + dx
            if 0 <= new_y <= number_of_rows - 1 and \
                    0 <= new_x <= number_of_columns - 1 and \
                    field[new_y][new_x] == "." and \
                    field_info[new_y][new_x] == -1:
                field_info[new_y][new_x] = field_info[y][x] + 1
                queue.append([new_y, new_x])


# テーブル各要素の最小値を採用する
def update_field_info_master(field_info_master, field_info, number_of_rows, number_of_columns):
    for row_i in range(number_of_rows):
        for column_i in range(number_of_columns):
            field_info_master[row_i][column_i] = min(field_info_master[row_i][column_i], field_info[row_i][column_i])


def solve():
    number_of_rows, number_of_columns = list(map(int, input().split()))  # Row, Column数
    field = [input() for _ in range(number_of_rows)]
    field_info_template = [[-1] * number_of_columns for _ in range(number_of_rows)]
    field_info_master = [[1000 * 1000] * number_of_columns for _ in range(number_of_rows)]

    for row_i in range(number_of_rows):
        for column_i in range(number_of_columns):
            if field[row_i][column_i] == "#":  # 各々の黒マスからBFSを行う
                starting_y, starting_x = row_i, column_i
                field_info_copy = deepcopy(field_info_template)
                bfs(field, field_info_copy, number_of_rows, number_of_columns, starting_y, starting_x)
                update_field_info_master(field_info_master, field_info_copy, number_of_rows, number_of_columns)

    # 結果をチェック
    # print("***********")
    # for update_field_info_master_line in field_info_master:
    #     print(update_field_info_master_line)

    number_of_operations = -1
    for row_i in range(number_of_rows):
        for column_i in range(number_of_columns):
            number_of_operations = max(number_of_operations, field_info_master[row_i][column_i])
    print(number_of_operations)
```